=begin pod

=TITLE Control Flow

=SUBTITLE Statements used to control the flow of execution

=begin comment

=head2 do

=head2 if/elsif/else

=head2 for

=head2 gather/take

=end comment

=head2 given

The C<given> statement is Perl 6's topicalizing keyword in a similar way that
C<switch> topicalizes in languages such as C.  In other words, C<given>
sets C<$_> inside the following block.  The keywords for individual cases
are C<when> and C<default>.  The usual idiom looks like this:

    given EXPR {
        when EXPR { ... }
        when EXPR { ... }
        default { ... }
    }

The C<given> statement is often used alone:

    given EXPR { .say; .Numeric; }

This is a lot more understandable than:

    { .say; .Numeric; }(EXPR)


=head3 default and when

A block containing a C<default> statement will be left immediately
when the sub-block after the C<default> statement is left.  It is
as though the rest of the statements in the block are skipped.

    given 42 {
        "This says".say;
        $_ == 42 and ( default { "This says, too".say; 43; } );
        "This never says".say;
    }
    # The above block evaluates to 43

A C<when> statement will also do this.

In addition, C<when> statements C<smartmatch> the topic (C<$_>) against
a supplied expression such that it is possible to check against values,
regular expressions, and types when specifying a match.

    for 42, 43, "foo", 44 {
        when Int { .say }
        default  { say "Not an Int" }
    }
    #-> 42 43 Not an Int 44

In this form, the C<given>/C<when> construct acts much like a set of
C<if>/C<elsif>/C<else> statements.  Be careful with the order of the
C<when> statements.  The following code says C<"Int"> not C<42>.

    given 42 {
        when Int { say "Int" }
        when 42  { say 42 }
        default  { say "huh?" }
    }
    #-> Int

=head3 proceed and succeed

Both C<proceed> and C<succeed> are meant to be used only from inside C<when>
or C<default> blocks.

The C<proceed> statement will immediately leave the C<when> or C<default>
block, skipping the rest of the statements, and resuming after the block.
This prevents the C<when> or C<default> from exiting the outer block.

    default {
        proceed;
        "This never says".say
    }
    "This says".say;

This is most often used to enter multiple C<when> blocks.  C<proceed> will
resume matching after a successful match, like so:

    given 42 {
        when Int   { say "Int"; proceed }
        when 42    { say 42 }
        when 40..* { say "greater than 40" }
        default    { say "huh?" }
    }
    # -> Int
    # -> 42

Note that the C<when 40..*> match didn't occur.  For this to match
such cases as well, one would need a proceed in the C<when 42> block.

This is not like a C<C> C<switch> statement, because the C<proceed> does
not merely enter the directly following block, it attempts to match
the C<given> value once more, consider this code:

    given 42 {
        when Int { "Int".say; proceed }
        when 43  { 43.say }
        when 42  { 42.say }
        default  { "got change for an existential answer?".say }
    }
    #-> Int
    #-> 42

...which matches the C<Int>, skips C<43> since the value doesn't match, matches
C<42> since this is the next positive match, but doesn't enter the
C<default> block since the C<when 42> block doesn't contain a C<proceed>.

By contrast, the C<succeed> keyword shortcircuits execution and exits the
entire C<given> block at that point.  It may also take an argument to
specify a final value for the block.

    given 42 {
        when Int {
            say "Int";
            succeed "Found";
            say "never this!";
        }
        when 42 { say 42 }
        default { say "dunno?" }
    }
    #-> Int

=begin comment

=head2 loop

=head2 repeat/while

=head2 repeat/until

=head2 unless

=head2 while

=head2 return

=head2 next

=head2 last

=head2 redo

=head2 goto

=end comment

=end pod

# vim: expandtab shiftwidth=4 ft=perl6
