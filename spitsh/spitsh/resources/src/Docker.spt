class Docker { }
class DockerImg { }

constant $*docker-cli = {
    Docker.install-cli;
    Cmd<docker>;
}

constant $*docker = {
    unless Cmd<docker> {
        if File</var/run/docker.sock> {
            Docker.install-cli;
        } else {
            ${ sh -c (HTTP<https://get.docker.com>.get) };
        }
    }
    Cmd<docker>;
};

constant $*docker-socket = '/var/run/docker.sock';

constant $*moby-github = GitHubRepo<moby/moby>;

constant File $?docker-cleanup = ${mktemp};
augment Docker {

    static method ~latest-build-ver {
        my $gh-release-url = $*moby-github.latest-release-url;
        die "unable to get latest docker version" unless $gh-release-url;
        $gh-release-url.${sed 's/.*\/v//'};
    }

    static method latest-build-tgz-url(-->HTTP) {
        my $latest-v = Docker.latest-build-ver;
        "https://get.docker.com/builds/Linux/x86_64/docker-{$latest-v}.tgz";
    }
    static method install-cli {
        unless Cmd<docker> {
            my $url = Docker.latest-build-tgz-url;
            note "getting latest build from $url";
            $url.get.${tar xz};
            note "installing to /usr/local/bin/docker";
            File<docker/docker>.move-to('/usr/local/bin/docker');
            File<docker>.remove;
        }
    }

    static method ?hello-world {
        ${ $*docker run -i --rm hello-world >X };
    }

    static method tmp($from, :@args, :$mount-socket --> Docker) {
        Docker.create($from, :@args, :$mount-socket)
              .append-to($?docker-cleanup);
        END {
            ${$*docker rm -f @($?docker-cleanup.slurp) *>X};
            $?docker-cleanup.remove;
        }
    }

    static method create(
        $from,
        :$name,
        :@args,
        :$mount-socket
        -->Docker
    ) {
        ${
            $*docker create -i
            ("--name=$_" if $name)
            ("-v=$*docker-socket:$*docker-socket" if $mount-socket)
            @args $from sh
        };
    }

    method ?exists ${ $*docker container inspect $self *>X }
    method Bool    { $self.exists }

    method copy($from,$to) {
        ${ $*docker cp $from "$self:$to" }
    }

    method ?remove { ${ $*docker rm -f $self >X} }

    method ?running {
        ${ $*docker inspect -f '{{.State.Status}}' $self } eq 'running';
    }

    method start-sleep {
        'while true; do sleep 1; done'.${ $*docker start $self };
    }

    method ?exec(Str $eval) {
        if $self.running {
            $eval.${ $*docker exec -i $self sh };
        } else {
            $eval.${ $*docker start -i $self };
        }
    }

    method commit(
        $name,
        :$tag,
        :$cmd,
        :$env,
        :$entrypoint,
        :$expose,
        :$label,
        :$onbuild,
        :$user,
        :$volume,
        :$workdir
        -->DockerImg) {
        my DockerImg $img-name = $name ~ (":$_" if $tag);
        ${$*docker commit
          ("-c=CMD $_" if $cmd )
          ("-c=ENV $_" if $env )
          ("-c=ENTRYPOINT $_" if $entrypoint)
          ("-c=EXPOSE $_" if $expose)
          ("-c=USER $_" if $user)
          ("-c=VOLUME $_" if $volume)
          ("-c=WORKDIR $_" if $workdir)
          $self
          $img-name
         } && $img-name;
    }
}

augment DockerImg {
    method ?exists { ${ $*docker image inspect $self *>X } }
    method ?remove { ${ $*docker rmi $self >X} }
    method Bool { $self.exists }
    method once-off($code) {
        $code.${ $*docker run -i --rm --entrypoint sh };
    }
}
