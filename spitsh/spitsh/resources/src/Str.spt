#| **internal** matches a perl regex
sub ?pre-match($str,$r) {
    $str.${perl -e '$_ = join("",<STDIN>); /@ARGV[0]/ or exit 1' $r};
}
#| **internal** matches a ERE
sub ?re-match($str,$r) { $str.${grep -Eq $r} }

#| The Str class is the base primitive class of Spit-sh. It represents
#| a string in the shell. Since all shell constructs are made out of
#| strings all types inherits from this class.
#|{
   say "foo" ~~ Str; # true
   say <one two three> ~~ Str; #true
}
augment Str {
    #| Prints the string to stdout
    method say { say $self }
    #| Prints the string to stderr
    method note { note $self }
    #| Returns an uppercase version of the string
    method ~uc    { $self.${tr '[:lower:]' '[:upper:]'} }
    #| Returns an lowercase version of the string
    method ~lc    { $self.${tr '[:upper:]' '[:lower:]'} }
    #| Returns the number of characters in the string. **note:** This
    #| will depend on the locale of the terminal the script is running in.
    method +chars { $self.${wc -m|tr -d ' '} }
    #| Returns the number of bytes in the string.
    method +bytes { $self.${wc -c|tr -d ' '} }

    #| Splits the string on a separator. Returns the string with each
    #| instance of the `$sep` replaced with `\n` as a [List].
    method @split(#|[The separator to split on]$sep) {
        $self.${
          awk -v "FS=$sep" '{l = split($0,a); for (i = 0; i < l;) print a[++i]}'
         }
    }
    #| Returns true if the string isn't empty
    method ?Bool { ${test $self} }

    constant $subst-awk = 'BEGIN { RS="^$"; r=ENVIRON["R"]; t=ENVIRON["T"] }
    {
     while( (g || !i) && (i = index($0,t)) )
       $0 = substr($0,1,i-1) r substr($0,i + length(t));
     print;
    }';

    #| Returns the string with the target string replaced by a replacement string.
    #| Does not modify the original string.
    #|{
       my $a = "food";
       $a.subst('o','e').say;
       $a.subst('o','e',:g).say;
       say $a;
    }
    method ~subst(#|[The string to be replaced]$target,
                  #|[The string to replace it with]$replacement,
                  #|[Turns on global matching]Bool :$g){
        $self.${awk -v "g=$g" $subst-awk :T($target) :R($replacement)};
    }
    #| Returns true if the string contains `$needle`.
    #|{
       say "Hello, World".contains('Wo'); #-> True
       say "Hello, World".contains('wo'); #-> False
       say "Hello, World".contains('wo',:i); #-> True
    }
    method ?contains(#|[The string being searched for]$needle,
                     #|[Turns on case insensitive matching]Bool :$i) {
            $self.${awk -v 'RS=^$' -v "t=$needle" -v "i=$i"
                  '{exit(!index(i ? tolower($0) :$0, i ? tolower(t) : t))}'}
    }

    #| Returns true if the string starts with the argument.
    #|{
        my @urls = <http://github.com ftp://ftp.FreeBSD.org>;
        for @urls {
            print "$_ is:";
            when .starts-with('http') { say "hyper text transfer" }
            when .starts-with('ftp')  { say "file transfer" }
            default { "well I'm not sure.." }
        }
    }
    method ?starts-with(#|[True if the string starts-with this]$starts-with) is native {  }

    #| Returns true if the string ends with the argument.
    #|{
        my @urls = <github.com ftp://ftp.FreeBSD.org>;
        for @urls {
            print "$_ might be: ";
            when .ends-with('.com') { say 'commercial' }
            when .ends-with('.org') { say 'an organisation' }
            when .ends-with('.io')  { say 'a moon of Jupiter' }
        }
    }
    method ?ends-with(#|[True if the string ends-with this]$ends-with) is native {  }

    method ~gist { $self }
}
