sub ef($str --> Str) is native  { }
sub et($str --> Str)  is native { }

#| Joins arguments on a `\n` creating a `List`.
sub list(*@list --> List) is native { }

sub e($str --> Str) { ${printf '%s' $str} }
#| Prints its argument to `$*OUT` with a newline
sub ?say($str)  { ${printf '%s\\n' $str > $*OUT}  }
#| Prints its argument to `$*ERR` with a newline.
sub ?note($str) { ${printf '%s\\n' $str >! }      }
#| Prints its argument to `$*OUT` with no newline.
sub print($str){ ${printf '%s' $str > $*OUT }   }

#| Prints the message to stdout and then exits
sub die($str)  { note($str) && $$.kill("TERM"); }

#| Suspends execution for an interval of time measured in seconds.
#| **note** `sleep(1)` can usually take floating point numbers but
#| they are NYI in spit.
sub sleep(Int $seconds) { ${sleep $seconds} }

sub ?prompt(Str $str,Bool :$default) {
    if $*interactive {
        my $yn = $default ?? '[Y/n]' !! '[y/N]';
        say "ðŸ‘» $str $yn";
        $?IN.get;
        given $~ {
            when ''       { $default  }
            when /^[yY]$/ { True      }
            when /^[nN]$/ { False     }
            default { prompt($str, :$default) }
        }
    } else {
        $default;
    }
}

sub ?not(Bool $thing) { !$thing }
