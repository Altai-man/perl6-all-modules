=begin pod :tag<perl6>

=TITLE Data structures

=SUBTITLE How Perl 6 deals with data structures and what we can expect from them.

=head1 Scalar structures

Some classes do not have any I<internal> structure, and to access parts of them
specific methods have to be used. Numbers, strings, and some other monolithic
classes are included in that class. They use the C<$> sigil, although complex
data structures can also use it.

    my $just-a-number = 7;
    my $just-a-string = "8";

There is a L<Scalar> class, which is used internally to assign a default value
to variables declared with the C<$> sigil.

    my $just-a-number = 333;
    say $just-a-number.VAR.^name; # OUTPUT: «Scalar␤»

Any complex data structure can be I<scalarized> by using the L<item
contextualizer C<$>|/type/Any#index-entry-%24_(item_contextualizer)>:

    (1,2,3, $(4,5))[3].VAR.^name.say; # OUTPUT: «Scalar␤»

However, this means that it will be treated as such in the context they are. You
can still access its internal structure.

    (1,2,3, $(4,5))[3][0].say; # OUTPUT: «4␤»

An interesting side effect, or maybe intended feature, is that scalarization
conserves identity of complex structures.

    for ^2 {
         my @list =(1,1);
         say @list.WHICH;
    } # OUTPUT: «Array|93947995146096␤Array|93947995700032␤»

Every time C<(1,1)> is assigned, the variable created is going to be different
in the sense that C<===> will say it is; as it is shown, different values of the
internal pointer representation are printed. However

    for ^2 {
      my $list =(1,1);
      say $list.WHICH
    }   # OUTPUT: «List|94674814008432␤List|94674814008432␤»

In this case, C<$list> is using the Scalar sigil and thus will be an C<Scalar>. Any scalar will the same value will be exactly the same, as shown when printing the pointers.

=head1 Complex data structures

Complex data structures fall in two different broad categories
L<Positional|/type/Positional>, or list-like and
L<Associative|/type/Associative>, or key-value pair like, according to how you
access its first-level elements. In general, complex data structures, including
objects, will be a combination of both, with object properties assimilated to
key-value pairs. While all objects subclass L<Mu>, in general complex objects are instances of subclasses of L<Any>. While it is theoretically possible to mix in C<Positional> or C<Associative> without doing so, most methods who apply to complex data structures are implemented in C<Any>.

Navigating these complex data structures is a challenge, but Perl 6 provides a couple of functions that can be used on them: L<C<deepmap>|/routine/deepmap> and L<C<duckmap>|/routine/duckmap>. While the former will go to every single element, in order, and do whatever the block passed requires,

    say [[1,2,[3,4]],[[5,6,[7,8]]]].deepmap( *.elems );
    # OUTPUT: «[[1 1 [1 1]] [1 1 [1 1]]]␤»

which returns 1 because it goes to the deeper level and applies C<elems> to
them, C<deepmap> can perform more complicated operations:

    say [[1,2,[3,4]],[[5,6,[7,8]]]].duckmap:
       -> $array where .elems == 2 { $array.elems }
    # OUTPUT: «[[1 2 2] [5 6 2]]␤»

In this case, it dives into the structure, but returns the element itself if it
does not meet the condition in the block (C<1,2>), returning the number of
elements of the array if it does (the two C<2>s at the end of each subarray).

Since C<d(eep|uck)map> are C<Any> methods, they also apply to Associative arrays:

    say %( first => [1,2], second => [3,4]).deepmap( *.elems )
    # OUTPUT: «{first => [1 1], second => [1 1]}␤»

Only in this case, they will be applied to every list or array that is a value, leaving the keys alone.

C<Positional> and C<Associative> can be turned into each other.

    say %( first => [1,2], second => [3,4]).list[0]# OUTPUT: «second => [3 4]␤»

However, in this case, and for Rakudo >= 2018.05, it will return a different
value every time you run. A hash will be turned into a list of the key-value
pairs, but it is guaranteed to be disordered. You can also do the operation in
the opposite direction, as long as the list has an even number of elements (odd
number will result in an error):

    say <a b c d>.Hash # OUTPUT: «{a => b, c => d}␤»

But

    say <a b c d>.Hash.kv # OUTPUT: «(c d a b)␤»

will obtain a different value every time you run it;
L<C<kv>|/type/Pair#method_kv> turns every C<Pair> into a list.

Complex data structures are also L<Iterable>. Generating an L<iterator> out of
them will allow the program to visit the first level of the structure, one by
one:

    .say for 'א'..'ס' # OUTPUT: «א␤ב␤ג␤ד␤ה␤ו␤ז␤ח␤ט␤י␤ך␤כ␤ל␤ם␤מ␤ן␤נ␤ס␤»

C<'א'..'ס'> is a L<Range>, a complex data structure, and with C<for> in front it
will iterate until the list is exhausted. You can use C<for> on your complex
data structures by overriding the L<iterator> method (from role C<Iterable>):

    class SortedArray is Array {
      method iterator() {
        self.sort.iterator
      }
    };
    my @thing := SortedArray.new([3,2,1,4]);
    .say for @thing; # OUTPUT: «1␤2␤3␤4␤»

C<for> calls directly the C<iterator> method on C<@thing> making it return the elements of the array in order.

=head1 Functional structures

Perl 6 is a functional language and, as such, functions are first-class I<data>
structures. Functions follow the L<Callable> role, which is the 4th element in
the quartet of fundamental roles. L<Callable> goes with the C<&> sigil, although
in most cases it is elided for the sake of simplicity; this sigil elimination is
always allowed in the case of C<Callables>.

    my &a-func= { (^($^þ)).Seq };
    say a-func(3), a-func(7)# OUTPUT: «(0 1 2)(0 1 2 3 4 5 6)␤»


=head1 Infinite structures and laziness

TBD

=head1 Introspection

TBD

=head1 Defining and constraining data structures

TBD

=end pod

# vim: expandtab softtabstop=4 shiftwidth=4 ft=perl6
